<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Springboot实现系统启动任务]]></title>
    <url>%2F2019%2F09%2F02%2FSpringboot%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[Spring Boot实现系统启动任务CommandLineRunner123456789@Component@Order(99)public class MyCommandLineRunner1 implements CommandLineRunner&#123; @Override public void run(String... args) throws Exception&#123; System.out.print("MyCommandLineRunner1&gt;&gt;&gt;"+Arrays.toString(args)) &#125;&#125; 123456789@Component@Order(98)public class MyCommandLineRunner2 implements CommandLineRunner&#123; @Override public void run(String... args) throws Exception&#123; System.out.print("MyCommandLineRunner2&gt;&gt;&gt;"+Arrays.toString(args)) &#125;&#125; 注意： 将系统启动类注册到容器当中去，使用@Component @Order表示优先级，数字越大，优先级越低 默认大小为Integer.MAX_VALUE 参数args表示的是系统启动的时候执行的参数，它的值是由启动类传过来的。 args参数配置 命令行启动传入args参数1java -jar commandlinerunner-0.0.1-SHAPSHOT.jar smallpineapple smallpineapple.github.io 参数跟在后面，多个参数用空格隔开 执行结果 ApplicationRunner123456789101112131415161718192021@Component@Order(99)public class MyApplicationRunner01 implements ApplicationRunner&#123; @Override public void run(ApplicationArguments args) throws Exception&#123; //获取启动的所有参数 String[] sourceArgs = args.getSourceArgs(); System.out.println("sourceArgs:"+Arrays.toString(sourceArgs)); //获取所有的无key参数 List&lt;String&gt; nonSourceArgs = args.getNonOptionArgs(); System.out.println("nonSourceArgs:" +Arrays.toString(nonSourceArgs)); Set&lt;String&gt; optionNames = args.getOptionNames(); System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"); for(String optionName : optionNames)&#123; System.out.println(optionName+":"+ args.getOptionValues(optionName)); &#125; System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;MyApplicationRunner01结束&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"); &#125;&#125; 12345678910111213141516171819202122@Component@Order(98)public class MyApplicationRunner02 implements ApplicationRunner&#123; @Override public void run(ApplicationArguments args) throws Exception&#123; //获取启动的所有参数 String[] sourceArgs = args.getSourceArgs(); System.out.println("sourceArgs:"+Arrays.toString(sourceArgs)); //获取所有的无key参数 List&lt;String&gt; nonSourceArgs = args.getNonOptionArgs(); System.out.println("nonSourceArgs:" +Arrays.toString(nonSourceArgs)); Set&lt;String&gt; optionNames = args.getOptionNames(); System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"); for(String optionName : optionNames)&#123; System.out.println(optionName+":"+ args.getOptionValues(optionName)); &#125; System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;MyApplicationRunner02结束&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"); &#125; &#125;&#125; 当项目启动时，这里的 run 方法就会被自动执行 关于 run 方法的参数 args getSourceArgs()获取所有的参数，包括key-value键值对和无key的值 getNonOptionArgs()获取所有无key参数 getOptionNames()获取所有key值 getOptionValues(optionName)根据key值获取value值 ApplicationRunner 定义完成后，传启动参数也是两种方式，参数类型也有两种，第一种和 CommandLineRunner 一致，第二种则是 –key=value 的形式 1java -jar devtools-0.0.1-SNAPSHOT.jar 三国演义 西游记 --age=99 运行结果]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>系统启动任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot通过CORS解决跨域问题]]></title>
    <url>%2F2019%2F09%2F02%2FSpringboot%E9%80%9A%E8%BF%87CORS%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Springboot通过CORS解决跨域问题同源策略同源策略是由 Netscape 提出的一个著名的安全策略，它是浏览器最核心也最基本的安全功能，现在所有支持 JavaScript 的浏览器都会使用这个策略。 所谓同源是指协议、域名以及端口要相同。 同源策略是基于安全方面的考虑提出来的，这个策略本身没问题，但是我们在实际开发中，由于各种原因又经常有跨域的需求。 传统的跨域方案是 JSONP，JSONP 虽然能解决跨域但是有一个很大的局限性，那就是只支持 GET 请求。 而今天我们说的 CORS（跨域源资源共享）（CORS，Cross-origin resource sharing）是一个 W3C 标准，它是一份浏览器技术的规范，提供了 Web 服务从不同网域传来沙盒脚本的方法，以避开浏览器的同源策略，这是 JSONP 模式的现代版 代码演示跨域失败 创建两个项目分别是CORS1和CORS2，端口分别为8080和8081 在CORS1中提供两个接口，分别是/hello，/byebye 12345678910111213@RestControllerpublic class Cors1Controller&#123; @PostMapping("/hello") public String hello()&#123; return "post---hello"; &#125; @GetMapping("/byebye") public String byebye()&#123; return "get---byebye"; &#125;&#125; 在COR2中的resources/static目录下创建HTML文件 编写AJAX向http://localhost:8080/hello发送请求 12345678910111213141516&lt;div id="app"&gt;&lt;/div&gt;&lt;input type="button" onclick="btnClick()" value="get_button"&gt;&lt;input type="button" onclick="btnClick2()" value="post_button"&gt;&lt;script&gt; function btnClick() &#123; $.get('http://localhost:8080/hello', function (msg) &#123; $("#app").html(msg); &#125;); &#125; function btnClick2() &#123; $.post('http://localhost:8080/byebye', function (msg) &#123; $("#app").html(msg); &#125;); &#125;&lt;/script&gt; 分别启动两个项目，并点击按钮，观察开发者工具的控制台： 1Access to XMLHttpRequest at &apos;http://localhost:8080/hello&apos; from origin &apos;http://localhost:8081&apos; has been blocked by CORS policy: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. 由于同源策略的限制，由8081端口发送的请求无法向8080端口发送。 添加@CrossOrigin注解 在暴露接口的一方加上@CrossOrigin注解，避开同源策略。 123456789101112131415@RestControllerpublic class HelloController &#123; //这个注解表示这两个接口接受来自 http://localhost:8081 地址的请求 @CrossOrigin(origins = "http://localhost:8081") @PostMapping("/hello") public String hello() &#123; return "post---hello"; &#125; @CrossOrigin(origins = "http://localhost:8081") @GetMapping("/byebye") public String hello2() &#123; return "get---byebye"; &#125;&#125; @CrossOrigin注解源码解析 测试这个表示服务端愿意接收来自http://localhost:8081/的请求，拿到这个信息后，浏览器就不会再去限制本次请求的跨域了。 问题分析如果每个Controller上都加这样一个注解，岂不是非常麻烦？ 在 Spring Boot 中，还可以通过全局配置一次性解决这个问题，全局配置只需要在SpringMVC配置类中重写 addCorsMappings 方法即可 12345678910@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping("/**") .allowedOrigins("http://localhost:8081") .allowedMethods("*") .allowedHeaders("*"); &#125;&#125; /** 表示本应用的所有方法都会去处理跨域请求 *表示所有请求方式(GET/POST/PUT/DELETE···)和请求头可以支持跨域提交， allowedMethods 表示允许通过的请求方式，allowedHeaders 则表示允许的请求头。 经过这样的配置之后，就不必在每个方法上单独配置跨域了。 存在的问题了解了整个 CORS 的工作过程之后，我们通过 Ajax 发送跨域请求，虽然用户体验提高了，但是也有潜在的威胁存在，常见的就是 CSRF（Cross-site request forgery）跨站请求伪造。跨站请求伪造也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF ，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法，举个例子： 假如一家银行用以运行转账操作的 URL 地址如下： http://icbc.com/aa?bb=cc ，那么，一个恶意攻击者可以在另一个网站上放置如下代码： &lt;img src=&quot;http://icbc.com/aa?bb=cc&quot;&gt; ，如果用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会遭受损失。 基于此，浏览器在实际操作中，会对请求进行分类，分为简单请求，预先请求，带凭证的请求等，预先请求会首先发送一个 options 探测请求，和浏览器进行协商是否接受请求。默认情况下跨域请求是不需要凭证的，但是服务端可以配置要求客户端提供凭证，这样就可以有效避免 csrf 攻击。 参考博客：https://www.javaboy.org/2019/0613/springboot-cors.html]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>CORS解决跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot静态资源访问]]></title>
    <url>%2F2019%2F09%2F01%2FSpringboot%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[默认的静态资源访问当我们构建好Springboot项目后会发现项目路径下会有resources/static文件夹，它就是默认存放静态资源的文件夹。 源码分析WebMvcAutoConfiguration 所以，静态资源的路径默认一共是有五个(优先级由上到下) classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public/ /：斜杠表示的是/webapp目录 自定义静态资源访问路径源码分析 由此我们可以分析： 可以通过配置文件中匹配其前缀名规则，即可自定义静态资源的访问路径与匹配规则。 例子12345spring: resources: static-locations: classpath:/smallpineapple/ mvc: static-path-pattern: /** 通过类添加自定义静态资源配置12345678910111213@Configurationpublic class WebMvcConfig implements WebMvcConfigurer&#123; @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler("/**") .addResourceLocations("classpath:/smallpineapple/"); registry.addResourceHandler("/**") .addResourceLocations("file:///"+uploadDir); &#125;&#125; 最后补充问：/**和/*有什么区别？ 由于这是一种Ant风格的路径匹配符，/** 表示可以匹配任意层级的路径，而/*表示匹配当前层级下的任何路径。 例子：通过类进行自定义静态资源配置 http://localhost:8080/project/smallpineapple/1.img http://localhost:8080/project/smallpineapple/img/1.img 上面这两个路径对访问1.img图片来说都是生效的，而如果/*则第二种无法访问。]]></content>
      <categories>
        <category>Springboot</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>静态资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring属性注入]]></title>
    <url>%2F2019%2F08%2F29%2FSpring%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[book.properties123book.id=19book.name=三国演义book.author=罗贯中 Book实体类123456789101112131415//注册到Spring容器@Component//加入classpath路径下的对应配置文件@PropertySource("classpath:book.properties")public class Book&#123; //注入属性的值,$&#123;&#125;动态获取配置文件中的值 @Value("$&#123;book.id&#125;") private Long id; @Value("$&#123;book.name&#125;") private String name; @Value("$&#123;book.author&#125;") private String author; /*getter and setter*/&#125; Springboot的属性注入类型安全的属性注入Spring的属性注入存在的问题 若属性较多，属性名较长较复杂，挨个输入的错误率大大提高，非常地不友好 解决方案1234567891011121314//注册到Spring容器@Component//加入classpath路径下的对应配置文件@PropertySource("classpath:book.properties")//将配置文件中符文的所有前缀的属性的值一一注入@ConfigurationProperties(prefix="book")public class Book&#123; private Long id; private String name; private String author; /*getter and setter*/&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用类详解]]></title>
    <url>%2F2019%2F08%2F28%2F%E5%B8%B8%E7%94%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Object类 Object类是所有类的父类！它本身没有父类，它已经是顶层类。 equals(Object obj)方法123public boolean equals(Object obj)&#123; return this == obj;&#125; 返回值是布尔类型，方法参数为Object类型，即任何类型的参数都可以传递进去。 用于比较其它对象与本对象的内存地址是否相等。 引用数据类型 “==” 用于比较两个对象的内存地址。 12345678public static void main(String[] args)&#123; //Person类继承Object类，继承了Object类的equals方法 Person p1 = new Person("李四", 25); Person p2 = new Person("张三", 20); //Person的对象p1，调用父类的方法equals，进行对象的内存地址比较 boolean b = p1.equals(p2); System.out.println(b);&#125; Question： this指的是谁？ 谁调用的，就是谁，p1对象调用equals方法，所以this指的是p1对象 obj指的是谁？ 传递的参数对象，示例中的obj就是p2 两个对象比较地址没有意义！ 为使equals方法有意义，则在子类中重写equals()方法，可以比较两个对象中的成员变量，由于Object能传递任何类型的变量，所以存在安全隐患，所以应该在重写方法中判断传递过来的参数到底是什么。 123456789public boolean equals(Object obj)&#123; if (obj instanceof Person)&#123; //参数obj接受到的是Person对象，才能进行转型 //对obj参数进行向下转型,obj转成Person类型 Person p = (Person) obj; return (this.age == p.age); &#125; return false;&#125; 传递参数时会发生多态中的向上转型Person引用数据类型变量被提升为Object类型多态中的弊端：无法调用子类的特有内容！ 所以要向下转型： 12子类数据类型 变量名 = (子类数据类型) 父类数据类型变量名Person p = (Person) obj； 若传过来的参数为null,直接返回false； 若传过来的参数是自己本身，自己与自己比较，则直接返回true；增加上述判断情况可提高程序的执行效率！！！考虑更加周全！！！ toString()方法输出语句中，输出一个对象，则对象自动调用自身的toString()方法。 123456789101112public static void main(String[] args)&#123; //调用Person类的方法toString() //输出语句中，写的是一个对象，默认调用的toString方法 Person p = new Person("张三", 20); String s = p.toString(); System.out.println(p); System.out.println(s);&#125;Output：cn.itcast.demo01.Person@da6bf4cn.itcast.demo01.Person@da6bf4 重写方法toString()，因为没有必要让调用者看到内存地址 在开发中重写toString方法的一般要求：在方法中返回所有成员变量的值 String类特点 描述字符串对象的类，所有双引号内的内容都是String类的对象。 Question：String类打印它的对象，为什么不是对象地址？ ​ 因为它重写过toString方法。 注意字符串是常量， 它的值在创建后不能更改！ 但引用类型本身所指向的地址可以改变，每一个双引号都是String类型的对象。 12345678public static void main(String[] args)&#123; //引起变量str执行内存变化 //定义好的字符串对象，不变 String str = "smallpineapple"; System.out.println(str); str = "pig"; System.out.println(str);&#125; str对象可以指向不同的地址，但是双引号内的值是永远不变的。 因为String类源码本身定义了一个字符数组常量进行存储字符。 equal(Object obj)方法 方法传递字符串，判断字符串内的字符是否完全相同，若是则返回true equalsIgnoreCase(String s) 传递字符串，判断字符串中的字符是否相同，并且忽略大小写 int length() 返回字符串的长度 String subString(int beginIndex) 获取字符串的一部分，返回一个新的字符串 获取部分是[beginIndex, lastIndex - 1] boolean startsWith(String prefix) 判断一个字符串是否另一个字符串的前缀 boolean endsWith(String suffix) 判断一个字符串是否另一个字符串的后缀 char charAt(int index) 用于遍历字符串的每个字符，返回索引上的字符 StringBuffer类提高字符串的操作效率！！内部采用了可变数组的方式实现，数组的默认容量为16个字符！StringBuffer内部只有一个数组，String类只要有一个双引号就会创建一个新的数组。 StringBuffer append(String str) append(String str)方法的返回值是this，调用者是谁，返回值就是谁 delete(int start, int end) 删除缓冲区中的字符 包括开始索引上的字符，不包括结束索引上的字符 99%都是包含开始索引，不包含结束索引 insert(int index, 任意类型) 将任意类型的数据，插入到缓冲区的指定索引上 replace(int start, int end) 将指定索引范围内的所有字符，替换成新的字符串 reverse() 将缓冲区中的字符全部反转 StringBuilder类 StringBuilder里边的方法与StringBuffer里边的方法完全相同！！ 但是StringBuffer是线程安全的类，意味着运行速度慢； StringBuilder类是线程不安全的类，意味着运行速度快； 所以以后我们优先选用Builder类而不选用Buffer类。 Date类System.currentTimeMillis() 返回long类型参数 获取当前日期的毫秒值 时间原点：公元1970年1月1日，00:00:00 毫秒值就是0 时间与日期的计算都是以毫秒值来计算 构造方法Date(Long millis) 传递毫秒值，将毫秒值转成对应的日期对象 空参构造方法 获取操作系统中的时间与日期 long getTime() 返回毫秒值，将Date表示的日期转换为毫秒值 日期和毫秒值的转换 Date setTime(Long millis) 传递毫秒值，将日期对象，设置到指定毫秒值上 毫秒值转换成日期对象 SimpleDateFormat类 对日期的格式化(自定义) 日期格式化步骤 创建SimpleDateFormat类对象，在构造方法中写入字符串的日期格式(自定义) SimpleDateFormat调用方法format对日期进行格式化，String format(Date date) 传递日期对象，返回字符串 日期模式： 日期格式 含义 yyyy 年份 MM 月份 dd 天数 HH 0-23小时 mm 小时当中的分钟数 ss 分钟当中的秒数 format(Date date) 将日期对象转换为字符串后进行时间的输出，可以自定义日期格式 12345public static void function()&#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date = sdf.format(new Date()); System.out.println(date);&#125; parse(String date)parse()步骤： 1.创建SimpleDateFormat对象，构造方法中指定日期模式 2.子类对象，调用方法parse传递String，返回Date 12345public static void function() throws Exception&#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Date date = sdf.parse("1995-5-6"); System.out.println(date);&#125; Calendar类getInstance() 返回了子类的对象，不需要直接new，而是通过调用静态方法 int get(int number) 获取某个日历字段的值 12345678910public static void function()&#123; Calendar c = Calendar.getInstance(); //获取年份 int year = c.get(Calendar.YEAR); //获取月份,默认是0-11,所以需要+1 int month = c.get(Calendar.MONTH) + 1; //获取日期 int day = c.get(Calendar.DAY_OF_MONTH); System.out.println(year+"-"+month+"-"+day);&#125; set(int field, int value)设置日历 field表示日历的字段 value表示设置后的具体数值 set(int year, int month, int day) 设置三个整数的年，月，日 add(int field, int value) 日历的偏移量，可以指定一个日历中的字段，进行整数的偏移 System类static long currentTimeMillis() 获取系统当前的毫秒值 一般用于程序执行时间测试 static void exit() 退出虚拟机，所有程序全部停止 static void gc() JVM在内存中，收取对象的垃圾 static Properties getProperties() 获取当前操作系统的属性 static void arrayCopy(~~~)参数列表： 参数 含义 Object src 要复制的源数组 int srcPos 数组源的起始索引 Object dest 复制后的目标数组 int destPos 目标数组起始索引 int length 复制几个 Math类 方法 含义 static int abs(int i) 返回参数的绝对值 static double ceil(double d) 返回大于或等于d的最小整数(向上取整) static double floor(double d) 返回小于或等于d的最大整数(向下取整) static double pow(double a,double b) 返回a的b次方 static double sqrt(double d) 返回参数的平方根 static double random() 返回随机数0.0-1.0之间 static double round(double d) 获取参数的四舍五入值，取整数]]></content>
      <tags>
        <tag>JAVASE</tag>
        <tag>常用类详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2019%2F08%2F27%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[栈简单介绍栈就像一个乒乓球盒子，我们只能从其中的一个口放和取，而最后放进去的乒乓球总会是第一个被取出，这就是栈的最显著的特点：后进先出。 栈的特点 后进先出(Last In First Out) 有序列表 限制插入和删除只能在一端执行 , 允许插入的一端称为栈顶, 另一端固定的称为栈底 最先放入栈的元素存在于栈底 , 最后放入的元素存在于栈顶 , 而删除元素正好相反 实现方式 数组 假设数组是$array$，上图所示栈顶元素是H，栈顶元素的下标是7，也就是$top=7$，$array[top] = H$ $top$是栈顶指针，也就是数组最后一个元素的下标。 链表 每一个节点都有其指向前一个节点的指针域$prev$、值域$data$以及指向后一个节点的指针域$next$，所以用链表实现栈，其实原理就是使用到双向链表。 其中栈顶元素为表尾节点，$top$是栈顶指针，永远指向表尾节点，*栈为空则指向空。 操作方式 入栈操作(push) 出栈操作(pop) 数组栈元素入栈过程 将栈顶元素对应的下标+1，使得栈顶的位置发生改变，并将元素放入当前栈顶位置下标所指向的数组位置。 数组栈元素出栈过程 将栈顶元素对应的下标-1，使栈顶位置往前移动一位，并把原来栈顶的值“删除掉”，由于是数组，无法真正地删除一个已经分配的内存空间，所以我们只需要默认它不存在就好了。 链表栈元素入栈过程 将链表最后一个节点的next指针域指向待放入栈的元素 将新的节点的prev指针域指向当前的top指针指向的节点 将top指针指向新的元素 链表栈元素出栈过程 啊啊啊 将链表的尾节点的前一个节点的next指针域指向null 将top指针(表尾指针)指向倒数第二个节点(通过尾节点的prev指针域) 将原尾节点的prev域指向空，值清空 小结了解了栈的实现方式和基本操作的过程以及栈的特点以后，我们可以用它来应付在生活中的问题，接下来为大家讲解一道比较经典的关于使用栈这种数据结构的题目。 题目描述（leetcode-682）:你现在是棒球比赛记录员。 给定一个字符串列表，每个字符串可以是以下四种类型之一： 整数（一轮的得分）：直接表示您在本轮中获得的积分数。 “+”（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。 “D”（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。 “C”（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效 回合的分数是无效的，应该被移除。 每一轮的操作都是永久性的，可能会对前一轮和后一轮产生影响。 你需要返回你在所有回合中得分的总和。 示例输入：[“5”,”2”,”C”,”D”,”+”] 输出：30 第1轮：你可以得到5分。总和是：5。 第2轮：你可以得到2分。总和是：7。 操作1：第2轮的数据无效。总和是：5。 第3轮：你可以得到10分（第2轮的数据已被删除）。总数是：15。 第4轮：你可以得到5 + 10 = 15分。总数是：30。 前提要求： 输入列表的大小将介于1和1000之间。 列表中的每个整数都将介于-30000和30000之间。 思路 首先输入一个数组 , 如果不满足前提要求则直接返回0 , 如果满足 , 则继续进行判断 用一个栈去表示数组中每一个位置的分数 , 如果遇到字母”D”, 则访问栈顶元素并乘2后放入栈中 , 注意原来的元素没有弹栈! 如果遇到”+”时则访问(注意是访问而没有弹栈)栈的最上2个元素进行加操作后再放入栈顶 , 只有在遇到字母 “C”时, 则弹出栈顶元素 , 最后对栈内所有元素进行求和. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; private Stack&lt;Integer&gt; numStack = new Stack&lt;Integer&gt;(); public int calPoints(String[] ops) &#123; //判断长度是否超出题目要求 if(ops.length &gt; 1000 || ops.length &lt; 1)&#123; return 0; &#125; for (int i = 0; i&lt;=ops.length-1 ; i++)&#123; try&#123; int number = Integer.parseInt(ops[i]); //判断数字大小是否超出题目要求 if(number &gt; 30000 || number &lt; -30000)&#123; return 0; &#125;else&#123; numStack.push(number); &#125; &#125;catch(Exception ex)&#123; //栈判空, 若为空, 则此次操作没有任何意义 if(numStack.empty())&#123; continue; &#125; //不是数字, 会抛出异常, 此时不抛出, 作操作判断 switch (ops[i])&#123; case "C": numStack.pop(); continue; case "D": Integer peek = numStack.peek(); numStack.push(peek*2); continue; case "+": if(numStack.size() &lt; 2)&#123; numStack.push(numStack.peek()); &#125;else&#123; Integer top = numStack.peek(); Integer second = numStack.get(numStack.size() - 2); numStack.push(top+second); &#125; continue; default: break; &#125; &#125; &#125; //求和 int sum = 0; for (Integer integer : numStack) &#123; sum += integer; &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVASE-多态]]></title>
    <url>%2F2019%2F08%2F26%2FJAVASE-%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[对象的多态性 体现为父类引用变量可以指向子类对象 多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态 在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法 定义格式1父类类型或接口类型 引用变量 = new 子类对象(); 成员变量的特点编译时：参考父类是否有该成员变量，如果有则编译成功，否则编译失败 运行时：运行的是父类的变量值 编译和运行都是参考父类中的成员变量 成员方法的特点编译时：参考父类是否有该成员方法 运行时：运行的是子类的重写方法 编译看父类有没有此成员方法，运行参考子类的成员方法。 多态中的关键字 instanceof多态中的关键字： instanceof 比较运算符，返回真假值，可以用于比较引用数据类型 多态中的转型 父类的引用 变量名 = new 子类的对象(); JAVA强制数据类型的语言，参与运算的数据要保证类型的统一性！ 向上转型：可以调用父类的共有成员方法，无法调用子类的特有成员方法！ 若要调用子类特有成员方法，则需向下转型 ！ 子类数据类型 变量名 = (子类数据类型) 父类数据类型变量]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVASE-接口]]></title>
    <url>%2F2019%2F08%2F25%2FJAVASE-%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[接口的概念 接口是功能的集合，同样是一种数据类型，是比抽象类更为抽象的“类”。 接口只描述所应该具备的方法，并没有具体实现，具体的实现由接口的实现类（相当于接口的子类）来完成。这样将功能的定义与实现分离，优化了程序设计。 接口的定义抽象方法1public abstract 返回值类型 方法名字(参数列表); 接口中的成员方法全部都为抽象方法！ 可以省略修饰符public abstract，但仍然存在！ 成员变量1public static final 数据类型 变量名 = 值 特点 接口中的成员变量都为常量！！ 在接口中定义常量，可省略修饰符public static final，但仍然存在！ 调用方法1接口.成员变量 常量被静态修饰，可以被类名直接调用，被接口的名字直接调用 接口的多实现 一个类可以实现多个接口(区别继承) 类的多继承存在安全隐患(同样的函数无法识别该调用哪个函数) Q：接口多实现的安全隐患存在吗？ A：没有安全隐患。因为接口中的方法是抽象方法，没有方法体，实现类是负责重写抽象方法。所以调用实现类的重写方法时，不存在安全隐患！ 类继承类的同时可以实现多个接口 继承类只能是一个类，但可以实现多个接口，但子类(实现类)必须重写全部抽象方法才可以创建对象。 接口之间的多继承 接口与接口之间可以实现多个继承 一个接口可以同时继承多个接口。 接口与抽象类的区别 接口和抽象类的比较相同点： 都位于继承的顶端，用于被其它类实现或继承 都不能直接实例化对象 都包含抽象方法，其子类必须重写这些抽象方法 不同点： 抽象类为部分方法提供实现，避免子类重复实现这些方法，提高代码重用性；接口只能包含抽象方法； 一个类只能继承一个父类，却可以实现多个接口（接口弥补了JAVA的单继承） 抽象类应该是这个事物应该具备的内容，继承体系中是 is…a 关系 接口是这个事物中的额外功能，继承体系中是 has…a 关系 抽象类和接口的选用 优先选择接口，尽量少用抽象类 需要定义子类的行为，又要为子类提供共性功能时才选用抽象类]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVASE-抽象类及抽象方法]]></title>
    <url>%2F2019%2F08%2F25%2FJAVASE-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%8A%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[抽象类特点 用abstract关键字修饰 无法直接创建对象，原因：调用抽象方法没有意义 只有覆盖了抽象类中的所有抽象方法，其子类才可以创建对象，否则该子类依然是一个抽象类 之所以继承抽象类，更多的是在思想，面对共性类型操作更简洁。 与抽象类不可并存的关键字 private：私有方法子类无法继承，所以更不存在覆盖，与实现抽象方法相互矛盾。 final ：final关键字修饰在类上表示这是一个最终类，无法被继承，与abstract关键字共存会互相矛盾。 static ：因为static修饰的方法是静态方法，其可以直接被类所调用。而abstract修饰的方法为抽象方法，即无方法体的方法，不能够被直接调用，需要在子类或实现类中去编写完整的方法处理逻辑后才能使用。互相矛盾。 示例抽象类 子类]]></content>
      <categories>
        <category>JAVASE</category>
      </categories>
      <tags>
        <tag>JAVASE</tag>
        <tag>抽象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[稀疏数组]]></title>
    <url>%2F2019%2F08%2F25%2F%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[1.稀疏数组(sparsearray)1.1 应用场景 :当一个数组中大部分为0或者为同一个数值时可转化为稀疏数组进行存储 例子 : 五子棋棋盘 假设黑棋为1, 白棋为2, 其它未放置棋子的位置为0, 则可得到如下一个二维数组 如果我要保存当前棋盘的状态 , 保存没有放置棋子的地方是毫无意义而且浪费内存空间的 , 所以此时稀疏数组可以起到非常大的作用. 1.2什么是稀疏数组 稀疏数组共有3列 , 第1列表示行, 第2列表示列, 第三列表示值. 稀疏数组的第1行保存原数组中共有多少行, 多少列与多少个有效值 第2行开始保存每一个有效值所处的行数, 列数与对应的值 1.3 二维数组对应的稀疏数组​ 行 列 值 这样做的好处是将9*9=81个值压缩成3*7=21个值保存, 大大减小了占用的内存空间 1.4 压缩数组思路 ① 遍历原始二维数组 , 得到有效数据的个数count ② 根据count创建稀疏数组 , 行数为(count+1), 因为第一行保存原数组的行列及有效值个数, sparseArray[count+1][3] ③ 将原二维数组的有效数据存放到sparseArray当中 1.5 解压数组思路 ① 读取稀疏数组的第一行, 构建原始数组 array[sparseArray[0][0]][sparseArray[0][1]] ②从稀疏数组的第二行开始读取数据存放到原始数组中 1.6 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.smallpineapple.sparseArray;public class SparseArray &#123; public static void main(String[] args)&#123; //构建原二维数组 int chessArr[][] = new int[9][9]; chessArr[3][1] = 1; chessArr[3][2] = 2; chessArr[3][3] = 2; chessArr[3][4] = 2; chessArr[3][5] = 2; chessArr[4][5] = 1; //输出原始二维数组 System.out.println("原始的二维数组:"); for (int[] row : chessArr) &#123; for (int item : row) &#123; System.out.print(item+" "); &#125; System.out.println(); &#125; //遍历原始二维数组的有效数据 int count = 0; for (int[] row : chessArr) &#123; for (int item : row) &#123; if(item!=0)&#123; count++; &#125; &#125; &#125; System.out.println("有效数据个数为:"+count); //创建稀疏数组 int sparsearray[][] = new int[count+1][3]; sparsearray[0][0] = 11; sparsearray[0][1] = 11; sparsearray[0][2] = count; //遍历二维数组, 将非0数据存放到数组当中去 int row = 1; for(int i=0;i&lt;9;i++)&#123; for(int j=0;j&lt;9;j++)&#123; if(chessArr[i][j]!=0)&#123; sparsearray[row][0] = i; sparsearray[row][1] = j; sparsearray[row][2] = chessArr[i][j]; //下一个数据存放到下一行 row++; &#125; &#125; &#125; //输出稀疏数组 System.out.println("稀疏数组:"); for (int i = 0; i &lt; sparsearray.length; i++) &#123; System.out.printf("%d\t%d\t%d\t", sparsearray[i][0],sparsearray[i][1],sparsearray[i][2]); System.out.println(); &#125; //稀疏数组转换成原始数组 int[][] transferArray = new int[sparsearray[0][0]][sparsearray[0][1]]; for (int i = 1; i &lt; sparsearray.length; i++) &#123; transferArray[sparsearray[i][0]][sparsearray[i][1]] = sparsearray[i][2]; &#125; //输出原始数组 System.out.println("原始数组形式:"); for (int[] a : transferArray) &#123; for (int i : a) &#123; System.out.print(i+" "); &#125; System.out.println(); &#125; &#125;&#125;输出结果 : 原始的二维数组:0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 2 2 2 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 有效数据个数为:6稀疏数组:11 11 6 3 1 1 3 2 2 3 3 2 3 4 2 3 5 2 4 5 1 原始数组形式:0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 2 2 2 2 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>稀疏数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析HTTP协议]]></title>
    <url>%2F2019%2F08%2F24%2F%E6%B5%85%E6%9E%90HTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[浅析HTTP协议!1. 引言1.1 HTTP是什么？HTTP(超文本传输协议)是一个应用层的、基于请求和响应模式的、无状态的面向对象的协议，常基于TCP协议，由于其简洁、快速而适用于分布式超媒体系统，绝大多数WEB开发，都是构建在HTTP协议之上的WEB应用。 1.2 HTTP的主要特点 支持客户端/服务器模式（Client/Server） 简单快速： ​ 客户端在向服务器发送请求服务时，只需指定请求的方法和路径即可。请求方法常用的方法有GET、POST、HEAD。每种方法向服务器发送请求所发生的联系的类型不同。 ​ 由于HTTP协议简单快速，使得其服务器程序规模小，通信速度很快。 灵活性高： ​ HTTP可以传输任意类型的数据对象，用Content-Type来标记。 无连接性： ​ 含义在于服务器每次只处理客户端发送的一个请求，处理完请求后并受到客户端的响应后自动与客户端断开。 无状态： ​ 无状态指的是对于事务处理没有记忆能力。所以如果服务器后续处理需要用到前面发送请求时所客户端携带的信息，则会增大此次连接的数据量，若每次均需要前面的信息，则数据量会一直增大。若服务器不需要先前携带的信息，那么它的应答会相比之下较快。 2. HTTP协议之URL篇HTTP URL(URL是一种特殊类型的URI，包含了用户查找某个资源的足够的信息)的格式如下： 1http://host[":"port][abs_path] HTTP要通过HTTP协议来定位网络资源 2.1 名词解释 host：表示合法的Internet主机域名或IP地址； port：表示一个端口号，若不指定则默认为缺省端口号80； abs_path：指定请求资源的URI；如果在RUL中没有给出asb_path，那么它作为URI时，会以”/“的形式给出 这个工作通常由浏览器为我们完成。 2.2 例子 www.gdou.edu.cn 浏览器会自动转换为：http://www.gdou.edu.cn http://192.168.0.112:8080/index.jsp 典型的往IP地址为192.168.0.112的8080端口发送请求，请求访问URI为index.jsp的资源。 3. HTTP协议之请求篇3.1 HTTP请求的组成部分 请求行； 消息报头(请求头)； 请求正文(请求体)。 3.1.1 请求行请求行以一个方法符号开头，以空格隔开，后面跟的是请求的URL和协议的版本 格式如下： Method Request-URI HTTP-Version CRLF(回车和换行) 如上图所示标号为①、②、③组成了请求行。 Method：表示发送请求的方法，下面列举出常用的HTTP请求的方法 GET：请求获取Request-URI所标识的资源 POST：在Request-URI所标识的资源后附加新的数据 PUT：请求服务器存储一个资源，并用Request-URI作为其标识 DELETE：请求服务器删除Request-URI所标识的资源 TRACE：请求服务器回送收到的请求信息，一般用于测试和诊断。 应用举例： ​ GET： 在浏览器的地址栏输入网址的方式访问网页时，浏览器会以GET方法的形式向服务器请求资源。 ​ GET /index HTTP/1.1(CLRLF) ​ POST：在向服务器发送请求时附加上自己需要携带的信息，不会显示在URI后面而会保存在请求正文(请求体)中 ​ 如上图所示，提交了三个信息并保存在请求正文中，浏览器会以键值对形式将信息进行存储并进行信息的利用。 123&lt;"name","tom"&gt;&lt;"password","1234"&gt;&lt;"realName","tomson"&gt; ​ PUT：常用于向服务器发送请求时更新一个资源，并携带上希望更新的信息标识及更新的内容。 ​ DELETE：常用于向服务器发送请求时删除一个资源，并鞋带上希望删除的信息标识。 3.1.2 请求报头稍后详述 3.1.3 请求正文(略) 4.HTTP协议之响应篇在接收到请求信息并处理完毕后，服务器会返回一个HTTP响应信息给客户端。 4.1 HTTP响应的组成部分 状态行(响应行) 消息报头(响应头) 响应正文(响应体) 4.1.1 状态行(响应行)格式如右 ： HTTP-Version Status-Code Reason-Phrase CRLF HTTP-Version表示服务器HTTP协议的版本； Status-Code表示服务器发回的响应状态代码； Reanson-Phrase表示状态码的描述 状态码(Status-code)介绍状态代码由3位数字组成，第1个数字定义了响应的类别，有5种可能取值： 1xx：表示消息已被服务器接收到，继续处理。 2xx：成功——表示请求已被成功接收、解析并接受 3xx：重定向——表示此次请求将被转换成另一个请求继续下一步的操作 4xx：客户端错误——表示请求无法被服务器接收 5xx：服务器端错误——服务器端未能正确处理客户端发送的请求。 常见状态码： 状态码 状态描述 说明 200 OK 客户端请求成功 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized 请求未经授权，此状态码必须与WWW-Authenticate报头一起食用 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 请求的资源不存在 eg：输入了错误的URL 500 Internal Server Error 服务器发生了不可预期的错误 eg：信息解析异常 503 Server Unavailable 服务器当前不能处理科幻段的请求，一段时间后可能恢复正常 4.1.2 响应报头(响应头)稍后详述 4.1.3 响应正文(响应体)就是服务器返回的资源的内容 5. HTTP协议之消息报头篇5.1 HTTP消息组成部分HTTP消息由客户端到服务器的请求及服务器到客户端的响应组成。请求消息和响应消息都是由下列四项组成： 开始行(对于请求消息，开始行就是请求行；对于响应消息，开始行就是状态行)； [消息报头](请求头/响应头)； 空行(CRLF)； [消息正文] 5.2 HTTP消息报头组成部分 普通报头 请求报头 响应报头 实体报头 每一个报头域都是由名字 + “:” + 空格 + 值组成，消息报头域的名字是大小写无关的。 5.2.1 普通报头在普通报头中，有少数报头域用于所有的请求和响应信息，但并不用于被传输的实体，只用于传输的信息。 eg： Cache-Control：用于指定缓存指令，缓存指令是： 单向的(响应中出现的缓存指令在请求中未必会出现) 独立的(一个消息的缓存指令不会影响另一个消息处理的缓存机制)，HTTP1.0使用的类似的报头域为Pragma 请求时的缓存指令包括：no-cache(用于指示请求或响应信息不能缓存)、no-store、max-age、max-stale、min-fresh、only-if-cached； 响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage 应用示例(eg)为了指示IE浏览器(客户端)不要使用缓存页面，服务器端的JSP程序可以编写如下代码： 12response.setHeader("Cache-Control","no-cache");//response.setHeader("Pragma","no-cache");作用和上述代码相同，通常二者合用 这句代码将在发送的响应信息中设置普通报头域：Cache-Control : no-cache Date普通报头域表示消息产生的日期和时间 Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定”close”选项，通知服务器，在响应完成后，关闭连接。 5.2.2 请求报头请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。 常用的请求报头 Accept ​ Accept请求报头域用于指定客户端接收哪种类型的信息。 ​ eg: ​ Accept: image/gif ​ 表示客户端希望接收GIF图像格式的资源； ​ Accept: text/html ​ 表示客户端希望接受html文本 Accept-Charset ​ Accept-Charset请求报头域用于指定客户端接受的字符集 ​ eg： ​ Accept-Charset: iso-8859-1, gb2312 ​ 如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。 Accept-Encoding ​ Accept-Encoding请求报头域类似于Accept，但是它可以指定可接受的内容编码。 ​ eg： ​ Accept-Encoding:gzip.deflate ​ 如果请求消息中没有设置这个域，则服务器假定客户端对各种内容编码都可以接受。 Accept-Lanuage ​ Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。 ​ eg： ​ Accept-Language: zh-cn ​ 如果请求消息中没有设置这个域则默认接受任何语言。 Authorization ​ 主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401(Not authorization)，可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。 Host(发送请求时，该报头域是必须需要的) ​ 该报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来。 ​ eg： ​ 输入：http://www.gdou.edu.cn ​ 浏览器发送的请求信息中，就会包含Host请求报头域，如下所示： ​ Host：www.gdou.edu.cn ​ 此处使用了缺省端口号80，若指定了端口号则会变为 www.gdou.edu.cn:port(端口号) User-Agent ​ 我们上网登陆论坛时，往往会看到一些欢迎信息，其中列出了自己正在使用的浏览器版本，操作系统等 等的个人可公开信息，这会让我们觉得很神奇，其实原因是在客户端向服务器发送请求时使用了User-Agent 这个报头域，它可以获取到你电脑中的一些信息，并发送给服务器，这就理所当然为什么服务器端知道你的 这些“隐私”啦。不过这个报头域不是必需的，不适用User-Agent这个报头域，那么服务器端就无法得知我们的 信息了。 应用示例 5.2.3 响应报头(响应头)响应报头允许服务器传递不能放在状态行(响应行)中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。 常用的响应报头 Location Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。 Server Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。 应用示例 5.2.4 实体报头请求和响应信息都可以传递一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送。实体报头定义了关于实体正文(eg:有无实体正文)和请求所标识的资源的元信息。 常用的实体报头 Content-Encoding Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指定了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型必须采用相应的解码机制。Content-Encoding用于记录文档的压缩方法 eg： Cotent-Encoding : gzip ​]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-7.整数反转]]></title>
    <url>%2F2019%2F08%2F24%2Fleetcode-7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[leetcode-7. 整数反转题目给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 $[-2^{31}, 2^{31}-1] $。请根据这个假设，如果反转后整数溢出那么就返回 0。 重点难点 : 判断溢出例子 : 假设输入一个数,并将其数字倒序输出, 如果超出范围为$[-2^{8}, 2^{8}-1]$则判断为溢出. 例如 : 示例 1: 输入 : 59 输出 : 95 示例 2: 输入 : 159 输出 : 0 此时, 假设输入整数 : 159, 倒序输出结果应为951 question1 : 那么我们该如何判断它溢出呢 ? 首先确定范围为$[-256, 255] $, 我们打算从最低位开始一位一位地反转, 将每一位取出后存储到一个变量$(ans)$中, 判断该变量是否已经超出了最大值的前$(n-1)$位…… question 2 : 为什么是判断$(n-1)$而不是$(n-2),(n-3),… $呢 ? 在溢出判断时, 我们最关心的是它在什么时候溢出, 那就是在最接近边界值的时候会溢出, 请看下面的图示 在每一位被取出时, 都与边界值的前$(n-1)$位的数值进行比较, 这样的好处就是当被反转的数准备取下一位进行反转时, 已经被反转的数值的位数有可能是$(n-1)$位, 那么如果此时如果该值已经大于边界值的前$(n-1)$位的最大值或小于边界值的前$(n-1)$位的最小值, 那么下一位已经没有必要再取出来作反转了, 因为前$(n-1)$位的数值已经溢出了, 最后一位再添加上去, 也必定溢出 补充 : 为什么是有可能 ? 因为反转的位数取决于用户输入的数字 , 如果输入的数字位数根本没有到$n$位, 例如 : 38, 不会溢出, 但是如果输入的数字原本是和边界值位数相同, 此时在最后一位被反转时, 已经被反转的数值的位数刚好是$(n-1)$位 question3 : 如果反转后的数值和边界值的前$(n-1)$位都相同, 那该怎么办 ? 这就是”强强对碰”了 , 胜负决定在第$n$位, 如果原来的数值的第n位数值比边界值小或比边界值大, 那么这个数就溢出, 因为第n位必定会跟在反转数值的最后一位 程序代码1234567891011121314151617181920public class Solution &#123; public int reverse(int x) &#123; int ans = 0; while (x != 0)&#123; //取末位数字 int pop = x % 10; //如果反转的数字大于整型的前n-1位, 则溢出 //或者反转后的数字刚好等于整型最大值的前n-1位, 但最后一位大于整型的最后一位, 也溢出 if (ans &gt; Integer.MAX_VALUE / 10 || ans == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; Integer.MAX_VALUE % 10)&#123; return 0; &#125;else if (ans &lt; Integer.MIN_VALUE / 10 || ans == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; Integer.MIN_VALUE % 10)&#123; return 0; &#125;else&#123; ans = ans * 10 + pop; x /= 10; &#125; &#125; return ans; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringDataJPA入门]]></title>
    <url>%2F2019%2F08%2F24%2FSpringDataJPA%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[SpringData JPA创建数据库表 注解 解释 @Entity 告诉Spring这是一个实体类 @Table(name = “表名”) 指定生成的数据表表名 @Column(name = “列名”) 指定生成的数据列的列名, 一般加在get方法上 @Id 指定主键列 @GeneratedValue 指定主键生成策略 @Transient 实体类中的某一个属性不映射到数据库的表中 @Temporal 指定日期类型(DATE,DATETIME, TIMESTAMP) 单向多对一关系 注解 解释 @JoinColumn(name= “外键列的列名”) 映射外键列的名称 @ManyToOne 映射多对一的关联关系 单向一对多关系 注解 解释 @OneToMany 映射一对多的关联关系 @JoinColum(name=”外键列列名”) 映射外键列的名称 单向 1-n 关联关系执行保存时, 一定回多出UPDATE语句, 因为多的一端在插入时不会同时插入外键列 默认情况下, 若删除1的一端, 则会先把关联的n的一端的外键置空, 然后进行删除, 注意这在实际意义当中并不有利 可以通过修改@OneToMany的 cascade属性来修改默认的删除策略. 设置@OneToMany的mappedBy属性, 可以让维护权交给多的一方维护 ，因为在多的一方没有完全删除完时，与其有关联关系的一的一方无法删除，所以由多的一方维护关联关系 双向多对一(多对一)关系 两个实体类中都有@ManyToOne属性, 且外键列的列名相同 若先保存n的一端, 再保存1的一端, 默认情况下, 会多出n条update语句 若先保存1的一端, 再保存n的一端, 默认情况下, 会多出n条update语句 在进行双向一对多关联关系时, 建议使用n的一方来维护关联关系, 而1的乙方不维护关联关系, 这样会有效的减少SQL语句. 注意 : 若在1的一端的@OneToMany使用mappedBy属性, 则多的一端的@ManyToOne端就不能再使用@JoinColumn属性 设置@OneToMany的mappedBy属性, 可以让维护权交给多的一方维护 ，因为在多的一方没有完全删除完时，与其有关联关系的一的一方无法删除，所以由多的一方维护关联关系 双向一对一关系 注解 解释 @OneToOne(mappedBy=”对方的属性”) 映射一对一的关联关系, 对于不维护关联关系, 没有外键的一方, 使用@OneToOne来映射, 建议设置mappedBy=true @JoinColumn(name=”外键列列名”, unique=true) 1 - 1关联关系, 需要添加unique=true 双向一对一的关联关系, 建议先保存不维护关联关系的一方, 即没有外键的一方, 这样不会多出update语句, 因为维护关系的一方先保存, 则外键列一开始为空, 后面再用update将外键列填补上 默认情况下, 若获取维护关联关系的一方, 则会通过左外连接获取其关联的对象 但可以通过@OneToOne的fetch属性来改变加载策略 默认情况下, 若获取不维护关联关系的一方, 则会通过左外连接获取其关联的对象 但可以通过@OneToOne的fetch属性来改变加载策略, 但依然会发送SQL语句来初始化其关联的对象 这说明在不维护关联关系的一方, 不建议修改fetch属性 双向多对多关系 注解 @ManyToMany @JoinTable(name=”表的名字”,joinColumns={@JoinColumn(name=”外键列名字”,referencedColumnName=”当前表的主键列列名”)},inverseJoinColumns={@JoinColumn(name=”关联的对象的外键列列命”, referencedColumnName=”关联的对方表的主键列列名”)}) 解释 映射多对多关联关系 映射中间表 @JoinTable 属性 : 1. name : 指向中间表的名字 2. joinColumns : 映射当前类所在的表在中间表的外键 2.1 name : 指定外键列的列名 ; referencedColumnName : 指定外键列关联当前表的哪一列的列名 3. inverseJoinColumns : 映射关联的类所在中间表的外键列名的名字; 3.1 name : 指定外键列的列名 ; referencedColumnName : 指定外键列关联当前表的哪一列的列名 使用维护关联关系或不维护关联关系的一方获取数据, SQL语句均相同. 二级缓存(Ehcache) 注解 解释 @Cachable(true) 被标注的实体类才会使用缓存 JPQL 注解 解释 @NamedQuery(name=””, query=””) 标注在类上, 用于查询 方法 entityManager.createNamedQuery(“name”) 用于添加@NamedQuery标注的查询语句 setParameter(location, value) location代表占位符的位置, value代表值 方法 解释 entityManager.createNativeQuery(sql) 用于执行sql语句 setParameter(location, value) location代表占位符的位置, value代表值 JPQL的ORDER BY 和 GROUP BY在JPQL里支持使用ORDER BY和GROUP BY语法 JPQL关联查询JPQL的关联查询同HQL的关联查询, 注意要加FETCH, 则得到的是一个对象, 而且对象的集合已经初始化成功了 JPQL子查询和HQL的子查询一样 JPQL函数 JPQL的UPDATE和DELETE语句与HQL编写语句相同]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>SpringData JPA</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在hexo博客插入图片]]></title>
    <url>%2F2019%2F08%2F23%2F%E5%A6%82%E4%BD%95%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[1. 在hexo根目录安装第三方插件1npm install https://github.com/7ym0n/hexo-asset-image --save 2. 修改_config.xml文件的内容1post_asset_folder: true 3. 插入md图片3.1 新建一个md文件1hexo n "title" 3.2 把待图片放入_posts文件夹下与title.md同名的文件夹title 3.3 在title.md中引入图片1![爱宠大机密](title/46ro0003sn14n066p757.jpg) 3.4 编译并运行12hexo ghexo s 3.5 成功]]></content>
      <tags>
        <tag>插入图片的步骤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学真的可以救命之约瑟夫问题]]></title>
    <url>%2F2019%2F08%2F23%2F%E6%95%B0%E5%AD%A6%E7%9C%9F%E7%9A%84%E5%8F%AF%E4%BB%A5%E6%95%91%E5%91%BD%E4%B9%8B%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[数学真的可以救命今天我们要解决的是约瑟夫问题, 首先我们先来了解链表到底是什么东东1 .链表的基本概念1.1 什么是链表 ?如下图所示 : SingleLinkedList代表单向链表 , 每一个结点含有 : data域 : 用于保存数据 next域 : 用于保存指向下一个结点的指针 DoubleLinkedList代表双向链表 , 每一个结点含有 : prev域 : 用于保存指向前一个结点的指针 data域 : 用于保存数据 next域 : 用于保存后一个数据的指针 对于头结点的说明 :头结点表示一个单链表第一个含有有效数据结点之前的结点, 它一般不保存数据, 用作链表的前驱 使用头结点和不使用头结点的不同 : ​ 使用头结点方便在第一个位置进行插入, 删除操作时和其它位置的插入删除操作的代码保持一致性 , 因为带上头结点之后 , 头指针永远不需要移动 , 而不带上头结点时 , 在第一个位置进行插入或删除操作时, 头指针需要移动 , 较为麻烦 , 有兴趣的读者可以尝试一下 , 这里不再详述…… 1.3 单向循环链表(不带头结点) 单向循环链表就是单向链表的升级版 , 尾结点的指针不再指向空 , 而是指向第一个结点 约瑟夫问题(也称”丢手帕问题”) 约瑟夫问题起源 :在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。 为什么约瑟夫一开始就知道站在16和31就一定能躲过自杀呢?这就是数学的魅力所在, 真香~ 外圈表示第几个自杀, 内圈表示每个人的序号 单向循环链表解决约瑟夫问题问题重述 :设有n个人围成一圈 , 编号从1到n , 约定从编号为k(1 &lt;= k &lt;= n)的人从1开始报数 , 数到 m 的那个人被淘汰 , 接着下一个人重新从1开始报数 , 数到 m 再淘汰一人 , 如此反复 , 直至剩下最后一个人为止 思路 :① 为什么使用单向循环链表 ? 我们可以知道约瑟夫问题是一个不断循环而且数据不断减少的过程 , 使用单向循环链表可以很方便地对数据进行删除 , 而且遍历链表方便 ② 理清过程 , 首先一个带有n个结点地单循环链表 , 从第k个人开始从1报数 , 那么首先需要将头指针指向第k个人 , 辅助删除指针指向第(k-1)个人 , 定义辅助删除指针的意义是为了方便当第k个人淘汰时 , 可以很方便的将第(k-1)的next指针指向第(k+1)个人, 当人数剩下一个人时 , 则认为这场游戏已经结束了 , 最后剩下的那个人就是胜利者 代码实现(JAVA版) :1.定义小孩的结点12345678910111213141516171819202122232425//定义一个Child结点, 每一个Child对象就是一个结点public class Child&#123; //编号 public Integer no; //指向下一个结点 public Child next; public Child(Integer no) &#123; super(); this.no = no; &#125; public Integer getNo() &#123; return no; &#125; public void setNo(Integer no) &#123; this.no = no; &#125; @Override public String toString() &#123; return "Node [no=" + no + "]"; &#125;&#125; 2.定义单向循环链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//定义SingleLinkedList来管理我们的Child结点class CircleLinkedList&#123; //第一个结点 private Child first = null; //当前的最后一个结点 private Child rear = null; //添加结点到单向链表 public void add(Child child)&#123; //判断当前链表是否为空 if(first == null)&#123; first = child; child.next = first; rear = child; &#125;else&#123; rear.next = child; child.next = first; rear = child; &#125; &#125; /** * 核心代码 * @param m 数到几出圈 * @param n 共有n个孩子玩游戏 * @param k 从第k个孩子开始报数 */ //开始游戏, 小孩出圈 public void play(int k, int m, int n)&#123; int count = 1; //使first指针和deleteNode指针指向第k个孩子和(k-1)个孩子 for(int i = 1; i&lt;=n; i++)&#123; if(i==k)&#123;break;&#125; first = first.next; rear = rear.next; &#125; //辅助删除指针, 需要删除元素时使用, 所以初始化时应该指向最后一个结点 //因为一开始第一个结点开始报数, 有可能报的是1, num也为1, 则首结点被淘汰 Child deleteNode = rear; if(n==1)&#123; System.out.println("你自己一个人玩, 你逃不掉了, 人数过少,无法开始游戏"); return ; &#125; System.out.println("被淘汰的小孩的编号为:"); count = 1; while(true)&#123; //只剩下一个人了 if(n==1)&#123; System.out.println(); System.out.println("存活的玩家是:"+first.getNo()); break; &#125; //判断是否数到m, 如果是则删除该结点 if(count == m)&#123; System.out.print(deleteNode.next.getNo()+" "); first = first.next; deleteNode.next = first; count = 1; //人数减少 n--; continue; &#125; //头指针与辅助删除指针都往后移一位 deleteNode = deleteNode.next; first = first.next; count++; &#125; &#125;&#125; 3. 代码运行1234567891011121314151617181920212223public class JosephuSolution &#123; public static void main(String[] args) &#123; CircleLinkedList circleLinkedList = new CircleLinkedList(); int i = 1; int n = 41; //生成小孩 while(i&lt;=n)&#123; Child child = new Child(i); circleLinkedList.add(child); i++; &#125; // k=1, m=3, n=41 circleLinkedList.play(1, 3, n); &#125; &#125;输出结果:被淘汰的小孩的编号为:3 6 9 12 15 18 21 24 27 30 33 36 39 1 5 10 14 19 23 28 32 37 41 7 13 20 26 34 40 8 17 29 38 11 25 2 22 4 35 16 存活的玩家是:31]]></content>
  </entry>
</search>
